PROBLEMAS DE SEGURIDAD CRÍTICOS DETECTADOS EN EL SISTEMA DE LOGIN
========================================================================

Fecha de detección: 15 de diciembre de 2025


PROBLEMA 1: NO SE USA password_verify()
----------------------------------------
Ubicación: includes/procesar_login.php (línea 28)
         includes/header.php (línea 11)

Descripción:
El sistema compara la contraseña en texto plano directamente en la query SQL
contra el hash almacenado en la base de datos. Esto NO funciona porque:
- En el registro se usa password_hash() para guardar un hash
- En el login se intenta comparar texto plano con hash en SQL
- Nunca coincidirán: password_hash() genera hashes diferentes cada vez

Código actual (INCORRECTO):
    $query = "SELECT ... WHERE Email = '" . $email . "' AND Clave = '" . $password . "'";

Solución requerida:
    1. Hacer SELECT solo por Email
    2. Obtener el hash de la BD
    3. Usar password_verify($password, $hash_bd) en PHP


PROBLEMA 2: SQL INJECTION VULNERABLE
-------------------------------------
Ubicación: includes/procesar_login.php (línea 28)
         includes/header.php (línea 11)

Descripción:
Se concatenan directamente las variables $email y $password en la query SQL
sin usar prepared statements ni escapar los valores. Esto permite inyección SQL.

Código actual (INCORRECTO):
    $query = "SELECT ... WHERE Email = '" . $email . "' AND Clave = '" . $password . "'";

Ejemplo de ataque:
    Email: admin@test.com' OR '1'='1
    Password: cualquiera

Solución requerida:
    Usar prepared statements con bind_param:
    $stmt = $db->prepare("SELECT ... WHERE Email = ?");
    $stmt->bind_param('s', $email);


PROBLEMA 3: CONTRASEÑA EN COOKIE SIN HASHEAR
---------------------------------------------
Ubicación: includes/procesar_login.php (línea 62)

Descripción:
Se guarda la contraseña en texto plano en la cookie 'recordarme_password'.
Cualquiera con acceso a las cookies del navegador puede ver la contraseña.

Código actual (INCORRECTO):
    setcookie('recordarme_password', $password, $duracion_cookie, '/', '', false, true);

Solución requerida:
    1. Generar un token aleatorio único (por ejemplo con bin2hex(random_bytes(32)))
    2. Guardar el token hasheado en la BD asociado al usuario
    3. Guardar solo el token (no hasheado) en la cookie
    4. Al verificar, comparar el token de la cookie con el hash en BD


PROBLEMA 4: COMPARACIÓN INCORRECTA HASH VS TEXTO PLANO
-------------------------------------------------------
Ubicación: includes/procesar_login.php (línea 28)
         includes/header.php (línea 11)

Descripción:
El sistema intenta hacer: WHERE Clave = '$password'
Pero 'Clave' contiene un hash generado por password_hash() y '$password' es texto plano.
Los hashes de password_hash() incluyen sal aleatoria, por lo que NUNCA coincidirán
directamente en una comparación de cadenas.

Ejemplo:
    password_hash("123456", PASSWORD_DEFAULT) puede generar:
    "$2y$10$abcd1234...xyz" (60 caracteres)
    
    Cada llamada genera un hash DIFERENTE aunque la contraseña sea la misma:
    "$2y$10$efgh5678...uvw" (60 caracteres)
    
    Por eso WHERE Clave = '123456' NUNCA encuentra el registro.

Solución requerida:
    NO comparar en SQL. Obtener el hash de la BD y usar password_verify() en PHP.


IMPACTO GENERAL
===============
Estos problemas hacen que:
1. El login actual probablemente NO FUNCIONE (si las contraseñas están hasheadas en BD)
2. El sistema sea vulnerable a SQL injection
3. Las contraseñas queden expuestas en cookies
4. No se aproveche la seguridad de password_hash()/password_verify()


PRIORIDAD
=========
CRÍTICA - Requiere corrección inmediata antes de producción
